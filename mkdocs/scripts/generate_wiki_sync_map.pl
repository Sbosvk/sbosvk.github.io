#!/usr/bin/env perl
use strict;
use warnings;
use utf8;
use Encode qw(decode);

my $repo_root = '.';
my $default_source = $ENV{SOURCE_ROOT} // $repo_root;
my $default_out = $ENV{WIKI_SYNC_MAP_FILE} // "$repo_root/mkdocs/scripts/wiki_sync_map.tsv";
my $source_root = $ARGV[0] // $default_source;
my $out_file = $ARGV[1] // $default_out;

-d $source_root or die "Missing source root: $source_root\n";

sub slugify {
  my ($s) = @_;
  $s = lc $s;
  $s =~ s/&/and/g;
  $s =~ s/[^a-z0-9]+/-/g;
  $s =~ s/^-+|-+$//g;
  $s =~ s/-{2,}/-/g;
  return $s;
}

sub split_segments {
  my ($stem) = @_;
  my @parts = split /-(?:\p{Pd}|:|-)-/u, $stem;
  @parts = grep { defined($_) && $_ !~ /^\s*$/ } @parts;
  return @parts;
}

sub join_slug {
  my (@parts) = @_;
  @parts = grep { defined($_) && length($_) } @parts;
  return join('-', @parts);
}

sub classify_additional_setup {
  my ($page) = @_;
  return 'backup' if $page =~ /(backup|restore|database)/;
  return 'moving-servers' if $page =~ /(migrate|replace|adding-a-game-server)/;
  return 'additional-installs';
}

opendir my $dh, $source_root or die "Cannot open $source_root: $!\n";
my @md_files = sort {
  (($a =~ /:-/) ? 1 : 0) <=> (($b =~ /:-/) ? 1 : 0) || $a cmp $b
} map { decode('UTF-8', $_) } grep {
  /\.md$/ &&
  $_ ne '_Sidebar.md' &&
  $_ ne '_Footer.md' &&
  -f "$source_root/$_"
} readdir $dh;
closedir $dh;

my @rows;
my %dest_seen;

for my $src (@md_files) {
  if ($src eq 'Home.md') {
    push @rows, [$src, 'index.md'];
    $dest_seen{'index.md'} = 1;
    next;
  }

  (my $stem = $src) =~ s/\.md$//;
  my @raw_segments = split_segments($stem);
  my @seg = map { slugify($_) } @raw_segments;
  next unless @seg;

  my $dest;

  if ($seg[0] eq 'getting-started') {
    my $page = join_slug(@seg[1..$#seg]);
    $dest = "getting-started/$page.md";
  } elsif ($seg[0] eq 'developer-guides') {
    my $page = join_slug(@seg[1..$#seg]);
    $dest = "developer-guides/$page.md";
  } elsif ($seg[0] eq 'specific-server-providers-setups') {
    my $page = join_slug(@seg[1..$#seg]);
    $dest = "additional-setup/provider-setups/$page.md";
  } elsif ($seg[0] eq 'additional-setup') {
    my $page = join_slug(@seg[1..$#seg]);
    my $bucket = classify_additional_setup($page);
    $dest = "additional-setup/$bucket/$page.md";
  } elsif ($seg[0] eq 'user-guide') {
    if (@seg >= 3 && $seg[1] eq 'main-interface') {
      if (@seg == 3) {
        $dest = "user-guide/main-interface/$seg[2].md";
      } else {
        my $section = $seg[2];
        my $page = join_slug(@seg[3..$#seg]);
        $dest = "user-guide/main-interface/$section/$page.md";
      }
    } else {
      my $page = join_slug(@seg[1..$#seg]);
      $dest = "user-guide/$page.md";
    }
  } elsif ($seg[0] =~ /^troubleshooting/ || $seg[0] eq 'help') {
    my $bucket = (@seg >= 2 && $seg[1] =~ /common-procedures/) ? 'common-procedures' : 'need-help';
    my $page = @seg >= 3 ? join_slug(@seg[2..$#seg]) : join_slug(@seg[1..$#seg]);
    $dest = "troubleshooting/$bucket/$page.md";
  } else {
    my $first = $seg[0];
    my $page = join_slug(@seg[1..$#seg]);
    $dest = "$first/$page.md";
  }

  if ($dest_seen{$dest}) {
    my $base = $dest;
    $base =~ s/\.md$//;
    if ($src =~ /:-/) {
      $dest = "$base-legacy.md";
    } else {
      my $n = 2;
      my $try = "$base-$n.md";
      while ($dest_seen{$try}) {
        $n++;
        $try = "$base-$n.md";
      }
      $dest = $try;
    }
  }

  $dest_seen{$dest} = 1;
  push @rows, [$src, $dest];
}

open my $out, '>:encoding(UTF-8)', $out_file or die "Cannot write $out_file: $!\n";
print {$out} "# Auto-generated by mkdocs/scripts/generate_wiki_sync_map.pl\n";
print {$out} "# Source wiki file<TAB>destination path under mkdocs/docs<TAB>optional nav label override\n";
for my $r (@rows) {
  print {$out} "$r->[0]\t$r->[1]\n";
}
close $out;

print "Generated $out_file with ", scalar(@rows), " entries from $source_root\n";
